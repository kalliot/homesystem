#!/usr/bin/env python

from datetime import datetime
import paho.mqtt.client as mqtt 
import os
import influxdb_client
import json
from time import sleep
import sys
import RPi.GPIO as GPIO
from queue import Queue
from influxdb_client.client.write_api import SYNCHRONOUS
from influxdb_client.domain.write_precision import WritePrecision


sys.path.insert(1, '/home/pi/config')
from setup import *


def saveData(recData):
    storage = "forever"

    client = influxdb_client.InfluxDBClient(
        url=influx_credentials.url,
        token=influx_credentials.token,
        org=influx_credentials.org
    )

    ts = int(recData['ts'])
    if recData['id'] == "quartcalc":
        tag = "quart"
        pointname   = 'calcsum' 
        name        = 'quart'
        solarw      = int(recData['solarW'])
        soldw       = int(recData['soldW'])
        creditedw   = int(recData['creditedW'])
        soldCents  = float(recData['soldCents'])
        creditedCents  = float(recData['creditedCents'])
        
        write_api = client.write_api(write_options=SYNCHRONOUS)
        p = influxdb_client.Point(pointname).tag("name",name)
        p.time(1000 * ts,write_precision=WritePrecision.MS)
        p.field("solarw", solarw)
        p.field("soldw", soldw)
        p.field("soldcents", soldCents)
        p.field("creditedw", creditedw)
        p.field("creditedcents", creditedCents)
        
        write_api.write(bucket=storage, org=influx_credentials.org, record=p)

    elif recData['id'] == "dailycalc":
        tag = "daily"
        pointname   = 'calcsum'
        name        = 'daily'
        solarw      = int(recData['solarW'])
        soldw       = int(recData['soldW'])
        creditedw   = int(recData['creditedW'])
        creditedEur  = round(float(recData['creditedCents']) / 100,4)
        heatOilEur  = round(float(recData['heatOilCents'])  / 100, 4)
        soldEur = round(float(recData['heatOilCents'])  / 100, 4)
        soldEur  = round(float(recData['soldCents'])  / 100, 4)
        consumedEur  = round(float(recData['consumedCents'])  / 100, 4)

        write_api = client.write_api(write_options=SYNCHRONOUS)
        p = influxdb_client.Point(pointname).tag("name",name)
        p.time(1000 * ts,write_precision=WritePrecision.MS)
        p.field("solarw", solarw)
        p.field("soldw", soldw)
        p.field("soldEur", soldEur)
        p.field("creditedw", creditedw)
        p.field("creditedEur", creditedEur)
        p.field("heatOilEur", heatOilEur)
        p.field("soldEur", soldEur)
        p.field("consumedEur", consumedEur)

        write_api.write(bucket=storage, org=influx_credentials.org, record=p)
    else:
        return    

    for consumer in recData['consumers']:
        pointname = consumer['type'] + 'calc' + tag
        name      = consumer['name']
        cents     = float(consumer['cents'])
        watts     = int(consumer['watts'])

        write_api = client.write_api(write_options=SYNCHRONOUS)
        p = influxdb_client.Point(pointname).tag("name",name)
        p.time(1000 * ts,write_precision=WritePrecision.MS)
        p.field("price", cents)
        p.field("watts", watts)

        write_api.write(bucket=storage, org=influx_credentials.org, record=p)



def on_message(client, userdata, message):
    msgqueue.put(message.payload)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        client.subscribe(mqtt_broker.topic_prefix + "/calculations/quart")
        client.subscribe(mqtt_broker.topic_prefix + "/calculations/daily")
        connected = True
    else:
        print("connection failed, rc=",rc)            
        connected = False

def on_disconnect(client, userdata, rc):
    if rc!=7:
        try:
            client.reconnect()
        except:
            print(datetime.now(),"reconnect failed, waiting...")
            sleep(30)

    else:
        sleep(30)
 

led = 13
GPIO.setwarnings(False)
GPIO.setmode(GPIO.BCM)
GPIO.setup(led, GPIO.OUT)

msgqueue = Queue(maxsize=5)
pid = os.getpid()

client = mqtt.Client("influx_calc_saver:" + str(pid))
client.on_connect = on_connect
client.on_message = on_message
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port=mqtt_broker.port, keepalive=60) 
print(datetime.now(), "Savecalc start")
client.loop_start()

while (True):
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        GPIO.output(led, GPIO.LOW)
        saveData(json.loads(data))
        sys.stdout.flush()
        GPIO.output(led, GPIO.HIGH)

    except KeyboardInterrupt:
        client.disconnect()
        GPIO.output(led, GPIO.HIGH)
        exit(0)

    except:
        raise
