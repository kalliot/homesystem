#!/usr/bin/env python

import time
from datetime import datetime
from datetime import timezone
import json
import paho.mqtt.client as mqtt 
import paho.mqtt.subscribe as subscribe
from queue import Queue
import sys

sys.path.insert(1, '/home/pi/config')
from setup import *

currentprice = 300                             # is 3eur/kwh enough high price?
currentconsumption = 0
W15min = 0
quart = 0
avgconsumption = currentconsumption
shellynumber = 1
pricelimit = 12                                # in cents
relayonminimum = 120                           # put is on minimum seconds
heaterpower = 2000                             # load controlled by relay is about 2000W


class heater:
    def __init__(self, shellynumber, relay, low, hysteresis):
        self.shellynumber = shellynumber
        self.relay = relay
        self.lowtemp = low
        self.hysteresis = hysteresis
        self.changets = int(time.time())
        self.state = False

    def setState(self, newState):
        if newState == self.state:
            return

        now = int(time.time())
        relaymsg = {
            'id': 'relay',
            'contact': self.relay,
            'duration': now - self.changets,
            'state': newState
        }
        setrelaytopic = mqtt_broker.topic_prefix + "/relay/shelly" + str(self.shellynumber) + "/setstate"
        client.publish(setrelaytopic,json.dumps(relaymsg), qos=0, retain=True)
        self.changets = now
        self.state = newState
        time.sleep(1)  # send consecutive relay orders with 1 sec delay



burner   = heater(1, 3, 51.8, 0.4)
elheater = heater(1, 0, 73.0, 2.0)

boilertempreader = "5bc674"
boilertempsensor = "28b867746008f"
boilertemp = 0.0


def getJsonNumericVar(source, name, defvalue):
    try:
        ret = float(source[name])
    except:
        print(datetime.utcnow(), "Warning: failed to read json variable", name)
        publishError("json", 1002, "failed to read json variable:" + name)
        return defvalue

    if ret != defvalue:
        print(datetime.utcnow(), "changed", name, "from", defvalue, "to", ret)
    return ret


def publishError(category, code, description):
    global shellynumber
    now = int(time.time())

    jsonRec = {
        "id"      :      "relayerror",
        "dev"     :      "shelly" + str(shellynumber),
        "ts"      :      now,
        "category":      category,
        "code"    :      code,
        "description" :  description
    }
    topic = mqtt_broker.topic_prefix + "/error/relay/shelly" + str(shellynumber)
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.utcnow(), "mqtt publish of error failed")


def processData(eldata):
    global currentprice, currentconsumption, boilertemp
    global avgconsumption, pricelimit, W15min, quart
    global relayonminimum, heaterpower, elheater

    if not (eldata.get('id') is None):
        id = eldata['id']

        if id == 'elprice':
            current_date = datetime.utcnow().strftime("%Y%m%d%H") 
            if (current_date != eldata['day']):
                publishError("datetime", 1001, "current prices timestamp is not valid:" + eldata['day'])
                print(datetime.utcnow(),"current prices timestamp is not valid")
            else:
                currentprice=int(eldata['notax'])
        
        elif id == 'heatsetup':
            print(datetime.utcnow(),"got heatsetup")
            relayonminimum    = getJsonNumericVar(eldata, 'relayonminimum',     relayonminimum)
            pricelimit        = getJsonNumericVar(eldata, 'pricelimit',         pricelimit)
            burner.lowtemp    = getJsonNumericVar(eldata, 'burner_lowtemp',     burner.lowtemp)
            burner.hysteresis = getJsonNumericVar(eldata, 'burner_hysteresis',  burner.hysteresis)
            elheater.lowtemp  = getJsonNumericVar(eldata, 'elheater_lowtemp',   elheater.lowtemp)
            elheater.hysteresis = getJsonNumericVar(eldata, 'elheater_hysteresis',  elheater.hysteresis)

        elif id == "relay":
            contact = int(eldata['contact'])
            # we come here atleast when somebody clics relay states from
            # the relay buttons or from the cloud.
            if contact == elheater.relay:
                elheater.setState(eldata['state'])

            elif contact == burner.relay:
                burner.setState(eldata['state'])

            elif contact == 1 or contact == 2:
                return    

            print(datetime.utcnow(), "received relay msg, setting", contact, "to", eldata['state'])

        elif id == "elproduction" and \
              eldata['phase'] == 'all':
            currentconsumption = int(eldata['power'])
            avgconsumption = int(eldata['poweravg'])
            W15min = float(eldata['W15min'])
            quart  = int(eldata['seconds'])

        elif id == "temperature" and \
             eldata['dev'] == boilertempreader and \
             eldata['sensor'] == boilertempsensor:
            boilertemp = float(eldata['value'])
   

    #-------------------------------------------------------------------
    # At the moment I don't have stock price agreement, so, no handling
    # of heating where price is low
    #-------------------------------------------------------------------

    # using avgconsumption, to put relay on more carelessly
    if boilertemp != 0.0: # value is something else than initial value
        if currentprice < pricelimit:
            timeleft = 900 - quart
            remain = heaterpower - avgconsumption
            # avoid division by zero
            if remain == 0:
                remain = 1
            result = (timeleft * remain / 3600) - W15min

            if timeleft > relayonminimum and \
                result < 5 and \
                boilertemp <= elheater.lowtemp:
                elheater.setState(True)
            elif W15min < 0.0 or \
                boilertemp >= (elheater.lowtemp + elheater.hysteresis):
                elheater.setState(False)
        else:
            # if price is high, dont care about consumption, just keep relay off.
            elheater.setState(False)

        if boilertemp <= burner.lowtemp:
            burner.setState(True)

        elif boilertemp >= (burner.lowtemp + burner.hysteresis):
            burner.setState(False)

    print(datetime.now(),"price:", currentprice, end=", ")
    print("consumption:", currentconsumption, end=", ")
    print("avgconsumption:", avgconsumption, end=", ")
    print("boilertemp:", boilertemp, end=", ")
    print("elstate:", elheater.state, end=", ")
    print("burnerstate:", burner.state)


def on_message(client, userdata, message):
    msgqueue.put(message.payload)


def logger(client, userdata, level, buff):
    print("level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(0,"connection failed, rc=",rc)
        connected = False


def on_disconnect(client, userdata, rc):
    client.reconnect()


def on_publish(client, userdata,result):
    pass


msgqueue = Queue(maxsize=10)


client = mqtt.Client("setrelay" + str(elheater.relay) + ":" + str(burner.relay)) #create new instance
client.on_connect = on_connect
client.on_message = on_message
client.on_publish = on_publish

client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()

topics = [(mqtt_broker.topic_prefix + "/elprice/current",0),
          (mqtt_broker.topic_prefix + "/phase/all/elproduction",0),
          (mqtt_broker.topic_prefix + "/esp" + boilertempreader + "/parameters/temperature/" + boilertempsensor,0),
          (mqtt_broker.topic_prefix + "/relay/+/shelly" + str(shellynumber) + "/state", 0),
          (mqtt_broker.topic_prefix + "/heating/setup",0)]

client.subscribe(topics)

while True:
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        processData(json.loads(data))
    except KeyboardInterrupt:
        client.disconnect()
        exit(0)
    except json.decoder.JSONDecodeError as e:
        print(datetime.utcnow(), "json:", e)
        print(datetime.utcnow(), data)
    except:
        raise        
