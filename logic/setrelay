#!/usr/bin/env python

import time
from datetime import datetime
from datetime import timezone
import json
import paho.mqtt.client as mqtt 
import paho.mqtt.subscribe as subscribe
from queue import Queue
import sys

sys.path.insert(1, '/home/pi/config')
from setup import *

class heater:
    def __init__(self, relay, low, high):
        self.relay = relay
        self.lowtemp = low
        self.hightemp = high
        self.state = False
        self.changed = False

currentprice = 300                             # is 3eur/kwh enough high price?
currentconsumption = 0
avgconsumption = currentconsumption
shellynumber = 1
pricelimit = 12                                # in cents
consumptionlimit = 2100                        # put relay on in if base consumption is below this
loadincrement = 2000                           # load controlled by relay is about 2000W
                                               # if load is on and consumption is over consumptionlimit - loadincrement
                                               # then put relay off
burner = heater(3, 52, 53)
elheater = heater(0, 65, 70)

boilertempreader = "5bc674"
boilertempsensor = "28b867746008f"
boilertemp = 0.0

def setRelay(state, relay):
    global elheater, shellynumber, burner

    relaymsg = {
        'id': 'relay',
        'contact': relay,
        'state': state
    }
    setrelaytopic="home/kallio/relay/shelly" + str(shellynumber) + "/setstate"
    client.publish(setrelaytopic,json.dumps(relaymsg))
    time.sleep(1)  # send consecutive relay orders with 1 sec delay 
    


def processData(eldata):
    global currentprice, currentconsumption, boilertemp
    global avgconsumption, pricelimit
    global consumptionlimit, loadincrement, elheater

    if not (eldata.get('id') is None):
        id = eldata['id']

        # first check nordpool price
        if id == 'elprice':
            current_date = datetime.utcnow().strftime("%Y%m%d%H") 
            if (current_date != eldata['day']):
                print(datetime.utcnow(),"current price is not valid")
            else:
                currentprice=int(eldata['price'])
        
        elif id == 'heatsetup':
            print(datetime.utcnow(),"got heatsetup")
            consumptionlimit = int(eldata['consumptionlimit'])
            loadincrement = int(eldata['heaterpower'])
            pricelimit = int(eldata['pricelimit'])

        elif id == "relay":
            contact = int(eldata['contact'])
            if contact == elheater.relay:
                elheater.state = eldata['state']

            elif contact == burner.relay:
                burner.state = eldata['state']

            elif contact == 1 or contact == 2:
                return    

            print("received relay msg, setting", contact, "to", eldata['state'])

        elif (id == "elproduction" and eldata['phase'] == 'all'):
            currentconsumption = int(eldata['power'])
            avgconsumption = int(eldata['poweravg'])

        elif id == "temperature" and eldata['dev'] == boilertempreader and eldata['sensor'] == boilertempsensor:
            boilertemp = float(eldata['value'])
   

        #-------------------------------------------------------------------
        # At the moment I don't have stock price agreement, so, no handling
        # of heating where price is low
        #-------------------------------------------------------------------

        # using avgconsumption, to put relay on more carelessly
    if currentprice < pricelimit:  
        if avgconsumption >= consumptionlimit:  
            if (elheater.state == False):
                elheater.changed = True
                elheater.state = True
        elif currentconsumption < (consumptionlimit - loadincrement):
                if elheater.state == True:
                    elheater.changed = True
                    elheater.state = False

    else: 
        # if price is high, dont care about consumption, just keep relay off.
        if elheater.state == True:
            elheater.changed = True
            elheater.state = False

    if boilertemp != 0.0: # value is something else than initial value
        if boilertemp <= burner.lowtemp:
            if burner.state == False:
                burner.state = True
                burner.changed = True

        elif boilertemp >= burner.hightemp:
            if burner.state == True:
                burner.state = False
                burner.changed = True

    print(datetime.now(),"price=", currentprice, "avgconsumption=", avgconsumption, "boilertemp=", boilertemp, "consumption=", currentconsumption, "elstate=", elheater.state, "burnerstate=", burner.state)
    if elheater.changed:
        elheater.changed = False
        setRelay(elheater.state, elheater.relay)

    if burner.changed == True:
        burner.changed = False
        setRelay(burner.state, burner.relay)


def on_message(client, userdata, message):
    msgqueue.put(message.payload)


def logger(client, userdata, level, buff):
    print("level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.utcnow(),"connection failed, rc=",rc)
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client, userdata,result):
    pass


msgqueue = Queue(maxsize=10)


client = mqtt.Client("setrelay" + str(elheater)) #create new instance
client.on_connect = on_connect
client.on_message = on_message
client.on_publish = on_publish

client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()

topics = [("home/kallio/elprice/current",0),
          ("home/kallio/phase/all/elproduction",0),
          ("home/kallio/esp" + boilertempreader + "/parameters/temperature/" + boilertempsensor,0),
          ("home/kallio/relay/+/shelly" + str(shellynumber) + "/state", 0),
          ("home/kallio/heating/setup",0)]

client.subscribe(topics)

while True:
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        processData(json.loads(data))
    except KeyboardInterrupt:
        client.disconnect()
        exit(0)
    except json.decoder.JSONDecodeError as e:
        print(datetime.utcnow(), "json:", e)
        print(datetime.utcnow(), data)
    except:
        raise        
