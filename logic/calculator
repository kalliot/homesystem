#!/usr/bin/env python

from datetime import datetime
import time
import json
import paho.mqtt.client as mqtt 
import sys
from queue import Queue

sys.path.insert(1, '/home/pi/config')
from setup import *

totalcents = 0
daycents = 0

class ElectricityPrice:
    def __init__(self):
        self.price = 0
        self.transferprice = 0
        self.buycommission = 0
        self.ts = int(time.time())

    def update(self, price, ts):
        self.price = price
        self.ts = ts

    def setup(self, transfer, commission):    
        self.buycommission = commission
        self.transferprice = transfer 

    def buyPrice(self):
        return self.price + self.buycommission + self.transferprice


class Consumer:
    def __init__(self, name, levels, power):
        self.name = name
        self.levels = levels
        self.power = power
        self.hourlyCents = 0
        self.dailyCents = 0
        self.currentLevel = 0
        self.ts = int(time.time())
        self.currentPower = 0

    def update(self, level, ts, price):
        seconds = ts - self.ts
        self.currentLevel = level
        self.hourlyCents += seconds / 3600 * self.currentPower / 1000 * price
        self.ts = ts
        self.currentPower = level / self.levels * self.power # in watts

    def hourChanged(self,ts, price):
        seconds = ts - self.ts
        self.hourlyCents += seconds / 3600 * self.currentPower / 1000 * price
        self.dailyCents += self.hourlyCents

    def reset(self, dayChanged):
        if dayChanged:
            self.dailyCents = 0
        self.hourlyCents = 0



elPrice = ElectricityPrice()
thermostat  = Consumer("thermostat", 29, 600)
stockheater = Consumer("stockheat", 1, 2000)


def processData(indata):
    global totalcents, daycents

    id = indata['id']

    if id == 'heatsetup':
        print(datetime.utcnow(),"received transferprice and commission",indata['eltransferprice'], indata['elprice'])
        elPrice.setup(float(indata['eltransferprice']), float(indata['elprice']))

    elif id == 'thermostat':
        print(datetime.utcnow(),"thermostat received level",indata['value'])
        newTs = int(indata['ts'])
        thermostat.update(int(indata['value']), newTs, elPrice.buyPrice())
        print(datetime.utcnow(),"Power is", thermostat.currentPower, "Thermostat cents for current hour, so far", thermostat.hourlyCents)

    elif id == 'relay':
        contact = int(indata['contact'])
        if contact == 2:
            state = indata['state']
            level = 0
            if state:
                level = 1
            print(datetime.utcnow(),"stockheater received level",level)
            newTs = int(indata['ts'])
            stockheater.update(level, newTs, elPrice.buyPrice())
            print(datetime.utcnow(),"Power is", stockheater.currentPower, "Stockheater cents for current hour, so far", stockheater.hourlyCents)


    elif id == 'elprice':
        print(datetime.utcnow(),"received price",indata['price'])
        newTs = int(indata['ts'])
        thermostat.hourChanged(newTs, elPrice.buyPrice())
        stockheater.hourChanged(newTs, elPrice.buyPrice())
        # send hourdata to mqtt
        print("---> Thermostat cents total for previous hour", thermostat.hourlyCents, "and for day", thermostat.dailyCents)
        print("---> Stockheater cents total for previous hour", stockheater.hourlyCents, "and for day", stockheater.dailyCents)
        elPrice.update(float(indata['price']), newTs)

        tm = time.localtime(newTs)
        dayChanged = (tm.tm_hour == 0)
        if dayChanged:
            # send dailydata to mqtt
            pass
        thermostat.reset(dayChanged)
        stockheater.reset(dayChanged)


def on_message(client, userdata, message):
    msgqueue.put(message.payload)


def on_connect(client, userdata, flags, rc):
    global connected

    if (rc==0):
        connected = True
    else:
        print(datetime.utcnow(),"connection failed, rc=",rc)
        connected = False


def on_disconnect(client, userdata, rc):
    print(datetime.utcnow(),"disconnected")
    if rc != 7:
        try:
            client.reconnect()
        except:
            print(datetime.utcnow(),"reconnect failed, waiting...")
            time.sleep(30)
    else:
        time.sleep(1)


def on_publish(client, userdata,result):
    pass

msgqueue = Queue(maxsize=10)


client = mqtt.Client('calculator') 
client.on_connect = on_connect
client.on_message = on_message
client.on_publish = on_publish

client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()


topics = [(mqtt_broker.topic_prefix + "/thermostat/+/parameters/level",0),
          (mqtt_broker.topic_prefix + "/heating/setup",0),
          (mqtt_broker.topic_prefix + "/relay/+/shelly1/state",0),
          (mqtt_broker.topic_prefix + "/elprice/current",0)]
client.subscribe(topics)


while True:
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        msg = json.loads(data)
        processData(msg)

    except KeyboardInterrupt:
        client.disconnect()
        exit(0)

    except json.decoder.JSONDecodeError as e:
        print(datetime.utcnow(), "json:", e)
        print(datetime.utcnow(), data)

    except:
        raise
