#!/usr/bin/env python

from datetime import datetime
import time
import json
import os
import paho.mqtt.client as mqtt 
import sys
from queue import Queue

sys.path.insert(1, '/home/pi/config')
from setup import *


class SolarNetto:
    def __init__(self):
        self.value = 0
        self.dailyWatts = 0
        self.sampleCnt = 0
        self.ts = int(time.time())

    def update(self,sample, ts):
        self.value += sample
        self.ts = ts
        self.sampleCnt += 1

    def hourChanged(self):
        ret = int(self.value / self.sampleCnt)
        self.dailyWatts += ret
        self.value = 0
        self.sampleCnt = 0
        return ret

    def reset(self):
        self.ts = int(time.time())
        self.dailyWatts = 0
        self.value = 0
        self.sampleCnt = 0

# Solar production is read from solis inverters daily variable
# Solis resets this when day changes and cumulates it while the
# day goes on and sun is shining. Update just compares the new
# value to previous.
class SolarProduction:
    def __init__(self):
        self.hourlyKw = 0
        self.dailyKw = 0
        self.ts = int(time.time())
        self.prevSample = -1

    def update(self, daily):
        if self.prevSample != -1:
            self.hourlyKw += (daily - self.prevSample)
        self.dailyKw = daily
        self.prevSample = daily

    def hourChanged(self,ts, reset):
        if reset:
            print(datetime.utcnow(), "solis reported solar production in prev hour was", round(self.hourlyKw * 1000),"watts.")
            self.hourlyKw = 0
        else:
            self.ts = ts

    def reset(self):
        self.hourlyKw = 0
        self.ts = int(time.time())
        self.dailyKw = 0
        self.prevSample = 0


class Pricing:
    def __init__(self):
        self.price = 0
        self.taxfreeprice = 0
        self.transferprice = 0
        self.buycommission = 0
        self.sellcommission = 0
        self.oilprice = 0 # in euros
        self.ts = int(time.time())

    def update(self, price, taxfree, ts):
        self.price = price
        self.taxfreeprice = taxfree
        self.ts = ts

    def setup(self, transfer, commission, sellcommission, oilprice):    
        self.buycommission = commission
        self.transferprice = transfer
        self.oilprice = oilprice
        self.sellcommission = sellcommission

    def buyPrice(self):
        return self.price + self.buycommission + self.transferprice

    def sellPrice(self):
        ret = self.taxfreeprice - self.sellcommission
        if ret < 0:
            ret = 0
        return ret

    def surplusPrice(self):
        return self.buyPrice() - self.sellPrice()

    def oilPrice(self):
        return self.oilprice * 10.8 # convert to cents per kwh and consider efficiency

class Consumer:
    def __init__(self, name, levels, power, priceFunc):
        self.name = name
        self.levels = levels
        self.power = power
        self.hourlyWatts = 0
        self.dailyWatts = 0
        self.hourlyCents = 0
        self.dailyCents = 0
        self.currentLevel = 0
        self.ts = int(time.time())
        self.currentPower = 0
        self.priceFunc = priceFunc

    def update(self, level, ts):
        minsaveinterval = 300 # if level is changed, save anyways
        seconds = ts - self.ts

        if seconds < 0: # in start this may become negative
            self.currentLevel = level
            self.ts = ts
            seconds = 0
            return

        if seconds < minsaveinterval and level == self.currentLevel:
            return

        self.currentLevel = level
        self.hourlyWatts += seconds / 3600 * self.currentPower
        self.hourlyCents = self.hourlyWatts / 1000 * self.priceFunc()
        self.ts = ts
        self.currentPower = level / self.levels * self.power # in watts
        print(datetime.utcnow(),"Power is", round(self.currentPower), self.name, "cents for current hour, so far", round(self.hourlyCents,2), ",watts", round(self.hourlyWatts))


    def publishHourChange(self, ts):
        jsonRec = {
                "id"      : "hourlycalc",
                "name"    : self.name,
                "ts"      : ts,
                "watts"   : round(self.hourlyWatts),
                "cents"   : round(self.hourlyCents,2)
            }
        topic = mqtt_broker.topic_prefix + "/calculations/hourly/" + self.name
        print(topic, json.dumps(jsonRec))
        #client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)

    def publishDayChange(self, ts):
        jsonRec = {
                "id"      : "dailycalc",
                "name"    : self.name,
                "ts"      : ts,
                "watts"   : round(self.dailyWatts),
                "cents"   : round(self.dailyCents,2)
            }
        topic = mqtt_broker.topic_prefix + "/calculations/daily/" + self.name
        print(topic, json.dumps(jsonRec))
        #client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)


    def hourChanged(self,ts):
        seconds = ts - self.ts
        if seconds < 0:
            seconds = 0
        self.hourlyWatts += seconds / 3600 * self.currentPower
        self.hourlyCents = self.hourlyWatts / 1000 * self.priceFunc()
        self.dailyCents += self.hourlyCents
        self.dailyWatts += self.hourlyWatts
        print(datetime.utcnow(), self.name, round(self.hourlyWatts,1), "/", round(self.dailyWatts,1),"Watts. Cents tot prev hour =", round(self.hourlyCents,2), ",day", round(self.dailyCents,2))

    def reset(self, dayChanged):
        if dayChanged:
            self.dailyCents = 0
            self.dailyWatts = 0
        self.hourlyCents = 0
        self.hourlyWatts = 0
        self.ts = int(time.time()) # restart hourly second counting.

class Consumers():
    def __init__(self, consumer):
        self.items = consumer

    def hourChanged(self, ts):
        for consumer in self.items:
            consumer.hourChanged(ts)

    def reset(self, dayChanged):
        for consumer in self.items:
            consumer.reset(dayChanged)

    def publishHourChange(self, ts):
        for consumer in self.items:
            consumer.publishHourChange(ts)

    def publishDayChange(self, ts):
        for consumer in self.items:
            consumer.publishDayChange(ts)

    def hourlyWatts(self):
        ret = 0
        for consumer in self.items:
            ret += consumer.hourlyWatts
        return ret

    def dailyWatts(self):
        ret = 0
        for consumer in self.items:
            ret += consumer.dailyWatts
        return ret

    def hourlyCents(self):
        ret = 0
        for consumer in self.items:
            ret += consumer.hourlyCents
        return ret

    def dailyCents(self):
        ret = 0
        for consumer in self.items:
            ret += consumer.dailyCents
        return ret

pricing = Pricing()
thermostat  = Consumer("thermostat",   29,   600, pricing.buyPrice)
stockheater = Consumer("stockheat",     1,  4000, pricing.buyPrice)
solheater   = Consumer("solheat",       1,  2000, pricing.surplusPrice)
storefridge = Consumer("sfridge",       1,    80, pricing.buyPrice)
heatpump    = Consumer("heatpump",    100,  2000, pricing.buyPrice)
burner      = Consumer("burner",        1, 20800, pricing.oilPrice) # 0.6gal/h = 2.27L/h -> 0.92 * 2.27 * 10 -> 20.8kw/h

solar       = SolarProduction()
solarNetto  = SolarNetto()

consumers = Consumers([thermostat,
                       stockheater,
                       solheater,
                       storefridge,
                       heatpump,
                       burner])


def processData(mqttdata):
    arr = mqttdata.topic.split("/")
    indata = json.loads(mqttdata.payload)
    item = arr[1]

    # bosch heatpump
    if item == "boiler_data":
        heatpump.update(int(indata['hpcompspd']), int(time.time()))
        return

    id = indata['id']
    if id == 'heatsetup':
        print(datetime.utcnow(),"received prices",indata['eltransferprice'], indata['elprice'],"heatoil",indata['heatoilprice'])
        pricing.setup(float(indata['eltransferprice']), float(indata['elprice']), float(indata['elselcommission']), float(indata['heatoilprice']))

    elif id == 'thermostat':
        newTs = int(indata['ts'])
        thermostat.update(int(indata['value']), newTs)

    elif id == 'cooler':
        newTs = int(indata['ts'])
        storefridge.update(int(indata['value']), newTs)

    elif id == 'state':
        if indata['sensor'] == 33:
            newTs = int(indata['ts'])
            burner.update(int(indata['value']), newTs)

    # handle devices which dropped out.
    elif id == 'device' and indata['connected'] == 0:
        newTs = int(time.time()) # data does not have a timestamp
        if indata['type'] == 'thermostat':
            thermostat.update(0, newTs)

    elif id == 'solarpower':
        solar.update(indata['energy_today'])

    elif id == 'relay':
        contact = int(indata['contact'])
        newTs = int(indata['ts'])
        if contact == 0: # solar energy heating
            state = indata['state']
            level = 0
            if state:
                level = 1
            solheater.update(level, newTs) # solheater starts only when there is enough solar energy
            

        elif contact == 2: # stock electricity heating
            state = indata['state']
            level = 0
            if state:
                level = 1
            stockheater.update(level, newTs)

    elif id == 'power15min':
        newTs = int(indata['ts'])
        solarNetto.update(indata['W15min'], newTs)
        if abs(newTs - solar.ts) < 15:
            netto = solarNetto.hourChanged()
            if netto > 0:
                creditedW = round(solar.hourlyKw * 1000) - netto
                creditedCents = round(solar.hourlyKw * pricing.buyPrice(),2)
                print(datetime.utcnow(),'credited solar production is', creditedW, 'W', creditedCents, 'cents')
                print(datetime.utcnow(),'Solar production is', netto,'W,',round(pricing.sellPrice() * netto / 1000,1),'cents.')
            else:
                creditedW = round(solar.hourlyKw * 1000)
                creditedCents = round(solar.hourlyKw * pricing.buyPrice(),2)
                print(datetime.utcnow(),'credited solar production is', creditedW, 'W', creditedCents, 'cents')
            solar.hourChanged(newTs, True)

    # elprice/current topic changes just after the hour has been changed.
    # this triggers many calculations and printing/topic updates.
    elif id == 'elprice':
        print(datetime.utcnow(),"The calculations are done with buyprice", pricing.buyPrice(), "and sellprice", pricing.sellPrice())
        newTs = int(indata['ts'])
        consumers.hourChanged(newTs)
        solar.hourChanged(newTs, False)
        consumers.publishHourChange(newTs)
        pricing.update(float(indata['price']), float(indata['notax']), newTs)

        tm = time.localtime(newTs)
        dayChanged = (tm.tm_hour == 0)
        if dayChanged:
            consumers.publishDayChange(newTs)
            solar.reset()

        consumers.reset(dayChanged)
        print("---------------------------------------------------------")

def on_message(client, userdata, message):
    msgqueue.put(message)


def on_connect(client, userdata, flags, rc):
    global connected

    if (rc==0):
        connected = True
    else:
        print(datetime.utcnow(),"connection failed, rc=",rc)
        connected = False


def on_disconnect(client, userdata, rc):
    print(datetime.utcnow(),"disconnected")
    if rc != 7:
        try:
            client.reconnect()
        except:
            print(datetime.utcnow(),"reconnect failed, waiting...")
            time.sleep(30)
    else:
        time.sleep(1)


def on_publish(client, userdata,result):
    pass

msgqueue = Queue(maxsize=10)


client = mqtt.Client('calculator' + str(os.getpid()))
client.on_connect = on_connect
client.on_message = on_message
client.on_publish = on_publish

client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()


topics = [(mqtt_broker.topic_prefix + "/thermostat/+/parameters/level",0),
          (mqtt_broker.topic_prefix + "/heating/setup",0),
          (mqtt_broker.topic_prefix + "/sensors/5bcae4/parameters/state/#",0),
          (mqtt_broker.topic_prefix + "/refrigerator/fd9030/parameters/state/#",0),
          (mqtt_broker.topic_prefix + "/110782219170385/solarpower",0),
          (mqtt_broker.topic_prefix + "/relay/+/shelly1/state",0),
          (mqtt_broker.topic_prefix + "/phase/all/quarterhnet",0),
          (mqtt_broker.topic_prefix + "/devices/#",0),
          ("ems-esp/boiler_data",0),
          (mqtt_broker.topic_prefix + "/elprice/current",0)]
client.subscribe(topics)


while True:
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        processData(data)

    except KeyboardInterrupt:
        client.disconnect()
        exit(0)

    except json.decoder.JSONDecodeError as e:
        print(datetime.utcnow(), "json:", e)
        print(datetime.utcnow(), data)

    except:
        raise
