#!/usr/bin/env python


 # weird situation in quart:
 # no solar production
 # heatpump consumption = 1229
 # total consumption = -3170
 # other is displayed as -1229
 # and sum is 0.

from datetime import datetime
from time import time, localtime, sleep
import json
from os import getpid as getpid
import paho.mqtt.client as mqtt 
from sys import path
from queue import Queue

path.insert(1, '/home/pi/config')
from setup import *

subtopic = '/calculations/'

class ElProduction:

    __slots__ = ('value', 'dailyWatts', 'ts')

    def __init__(self) -> None:
        self.value = 0
        self.dailyWatts = 0
        self.ts = int(time())

    def update(self,sample : int, ts : int) -> None:
        self.value = sample
        self.ts = ts

    def sampleAge(self) -> int:
        return int(time()) - self.ts

    def quartChanged(self) -> int:
        self.dailyWatts += self.value / 4
        return self.value

    def reset(self, dayChanged : bool) -> None:
        self.ts = int(time())
        self.value = 0

        if dayChanged:
            self.dailyWatts = 0

# Solar production is read from solis inverters daily variable
# Solis resets this when day changes and cumulates it while the
# day goes on and sun is shining. Update just compares the new
# value to previous.

class SolarProduction:
    __slots__ = ('quartKw', 'dailyKw', 'ts', 'prevSample')

    def __init__(self) -> None:
        self.quartKw = 0
        self.dailyKw = 0
        self.ts = int(time())
        self.prevSample = -1

    def update(self, daily : float) -> None:
        if self.prevSample != -1:
            diff = daily - self.prevSample
            if diff < 0: # solis has started a new day.
                self.reset()
                self.quartKw = daily
            else:
                self.quartKw += diff
        self.dailyKw = daily
        self.prevSample = daily

    def quartChanged(self,ts : int) -> None:
        print(datetime.utcnow(), "solis reported solar production in prev quart was", round(self.quartKw * 1000),"watts.")
        self.quartKw = 0
        self.ts = ts

    def reset(self) -> None:
        self.quartKw = 0
        self.ts = int(time())
        self.dailyKw = 0
        self.prevSample = 0


class Pricing:
    __slots__ = ('pendingPrice', 'pendingTaxFreePrice', 'price', 'taxFreePrice', 'transferprice', 'buycommission', 'sellcommission', 'oilprice', 'ts')

    def __init__(self) -> None:
        self.pendingPrice = 0
        self.pendingTaxFreePrice = 0
        self.price = -100
        self.taxFreePrice = 0
        self.transferprice = 0
        self.buycommission = 0
        self.sellcommission = 0
        self.oilprice = 0 # in euros
        self.ts = int(time())

    def update(self, price : float, taxfree : float, ts : int) -> None:
        self.pendingPrice = price
        self.pendingTaxFreePrice = taxfree
        if self.price == -100:
            self.price = price
            self.taxFreePrice = taxfree
        self.ts = ts

    def commitPrice(self,ts : int) -> None:
        self.ts = ts
        self.price = self.pendingPrice
        self.taxFreePrice = self.pendingTaxFreePrice

    def setup(self, transfer : float, commission : float, sellcommission : float, oilprice : float) -> None:
        self.buycommission = commission
        self.transferprice = transfer
        self.oilprice = oilprice
        self.sellcommission = sellcommission

    def buyPrice(self) -> float:
        return self.price + self.buycommission + self.transferprice

    def sellPrice(self) -> float:
        ret = self.taxFreePrice - self.sellcommission
        if ret < 0:
            ret = 0
        return ret

    def surplusPrice(self) -> float:
        return self.buyPrice() - self.sellPrice()

    def oilPrice(self) -> float:
        return self.oilprice * 10.8 # convert to cents per kwh and consider efficiency

class Consumer:
    __slots__ = ('name', 'isElectricity', 'levels', 'power', 'basepower', 'quartWatts', 'dailyWatts', 'quartCents', 'dailyCents', 'currentLevel', 'ts', 'currentPower', 'priceFunc')

    def __init__(self, name : str, levels : int, power : int, basepower : int, priceFunc, isElectricity : bool=True):
        self.name = name
        self.isElectricity = isElectricity
        self.levels = levels
        self.power = power
        self.basepower = basepower
        self.quartWatts = 0
        self.dailyWatts = 0
        self.quartCents = 0
        self.dailyCents = 0
        self.currentLevel = 0
        self.ts = int(time())
        self.currentPower = 0
        self.priceFunc = priceFunc

    def setDailies(self, watts : int, cents : float) -> None:
        self.dailyWatts = watts
        self.dailyCents = cents


    def update(self, level : int, ts : int) -> None:
        minsaveinterval = 60 # if level is changed, save anyways
        seconds = ts - self.ts

        if seconds < 0: # in start this may become negative
            self.currentLevel = level
            self.ts = ts
            seconds = 0
            return

        if seconds < minsaveinterval and level == self.currentLevel:
            return

        self.currentLevel = level
        self.quartWatts += seconds / 900 * self.currentPower
        self.quartCents = (self.quartWatts / 4) / 1000 * self.priceFunc()
        self.ts = ts
        self.currentPower = level / self.levels * self.power # in watts
        if self.currentPower:
            self.currentPower += self.basepower
        print(datetime.utcnow(),self.name, "Power is", round(self.currentPower), ". Cents for current quart so far", round(self.quartCents,2), ",watts", round(self.quartWatts))

    def setQuartPower(self, watts : int, ts : int) -> None:
        self.quartWatts = watts
        self.quartCents = self.quartWatts / 1000 * self.priceFunc()
        self.dailyCents += self.quartCents / 4
        self.dailyWatts += self.quartWatts / 4
        self.ts = ts

    def publishQuartChange(self, ts : int) -> dict:
        typ = "el"
        if not self.isElectricity:
            typ = "oil"

        jsonRec = {
                "name"    : self.name,
                "watts"   : round(self.quartWatts),
                "cents"   : round(self.quartCents,2),
                "type"    : typ
            }
        return jsonRec

    def publishDayChange(self, ts : int) -> dict:
        typ = "el"
        if not self.isElectricity:
            typ = "oil"

        jsonRec = {
                "name"    : self.name,
                "watts"   : round(self.dailyWatts),
                "cents"   : round(self.dailyCents,2),
                "type"    : typ
            }
        return jsonRec

    def quartChanged(self,ts : int) -> None:
        if self.power == 0: # other has 0 power. Other is updated in setQuartPower()
            return

        seconds = ts - self.ts
        if seconds < 0:
            seconds = 0
        self.quartWatts += seconds / 900 * self.currentPower
        self.quartCents = self.quartWatts / 1000 * self.priceFunc()
        self.dailyCents += self.quartCents / 4
        self.dailyWatts += self.quartWatts / 4
        print(datetime.utcnow(), self.name, round(self.quartWatts,1), "/", round(self.dailyWatts,1),"Watts. Cents tot prev quart =", round(self.quartCents,2), ",day", round(self.dailyCents,2))

    def reset(self, dayChanged : bool) -> None:
        if dayChanged:
            self.dailyCents = 0
            self.dailyWatts = 0
        self.quartCents = 0
        self.quartWatts = 0
        self.ts = int(time()) # restart quart second counting.



class Consumers():
    __slots__ = ('items', 'solarW', 'soldW', 'soldCents', 'creditedW', 'creditedCents', 'dailySolarW', 'dailySoldW', 'dailySoldCents','dailyCreditedW', 'dailyCreditedCents')

    def __init__(self, consumer : str) -> None:
        self.items = consumer
        self.solarW = 0
        self.soldW = 0
        self.soldCents = 0
        self.creditedW = 0
        self.creditedCents = 0
        self.dailySolarW = 0
        self.dailySoldW = 0
        self.dailySoldCents = 0
        self.dailyCreditedW = 0
        self.dailyCreditedCents = 0

    def setDailies(self, solarw : int, soldw : int, soldCents : float, creditedW : int, creditedCents : int) -> None:
        self.dailySolarW = solarw
        self.dailySoldW = soldw
        self.dailySoldCents = soldCents
        self.dailyCreditedW = creditedW
        self.dailyCreditedCents = creditedCents

    def getConsumer(self, name) -> Consumer:
        for consumer in self.items:
            if consumer.name == name:
                return consumer


    def totals(self, solarKw : float, soldW : int, creditedW : int) -> None:
        self.solarW = round(1000 * solarKw)
        self.soldW = soldW
        self.creditedW = creditedW
        self.creditedCents = (self.creditedW / 1000) * pricing.buyPrice()
        self.soldCents = soldW / 1000 * pricing.sellPrice()

        self.dailySolarW += round(1000 * solarKw)
        self.dailySoldW += soldW
        self.dailySoldCents += self.soldCents
        self.dailyCreditedW += creditedW
        self.dailyCreditedCents += self.creditedCents

    def quartChanged(self, ts : int) -> None:
        for consumer in self.items:
            consumer.quartChanged(ts)

    def reset(self, dayChanged) -> None:
        for consumer in self.items:
            consumer.reset(dayChanged)
        if dayChanged:
            self.dailySolarW = 0
            self.dailySoldW = 0
            self.dailyCreditedW = 0
            self.dailySoldCents = 0
            self.dailyCreditedCents = 0

    def publishQuartChange(self, ts : int) -> None:
        global subtopic
        consumerArr = []

        for consumer in self.items:
            consumerArr.append(consumer.publishQuartChange(ts))

        jsonRec = {
                "id"            : "quartcalc",
                "ts"            : ts,
                "solarW"        : self.solarW,
                "soldW"         : self.soldW,
                "soldCents"     : round(self.soldCents, 2),
                "creditedW"     : self.creditedW,
                "creditedCents" : round(self.creditedCents,2),
                "buyPrice"      : round(pricing.buyPrice(),2),
                "consumers"     : consumerArr
            }
        topic = mqtt_broker.topic_prefix + subtopic + "quart"
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)


    def publishDayChange(self, ts : int, prefix : str) -> None:
        global subtopic
        consumerArr = []
        oilCents = 0
        elCents = 0

        for consumer in self.items:
            if consumer.isElectricity:
                elCents += consumer.dailyCents
            else:
                oilCents += consumer.dailyCents
            consumerArr.append(consumer.publishDayChange(ts))

        jsonRec = {
                "id"            : prefix + "calc",
                "ts"            : ts,
                "solarW"        : self.dailySolarW,
                "soldW"         : round(self.dailySoldW,2),
                "creditedW"     : self.dailyCreditedW,
                "creditedCents" : round(self.dailyCreditedCents,2),
                "heatOilCents"  : round(oilCents,2),
                "soldCents"     : round(self.dailySoldCents,2),
                "consumedCents" : round(elCents,2),
                "consumers"     : consumerArr
            }
        topic = mqtt_broker.topic_prefix + subtopic + prefix
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)


    def quartWatts(self) -> int:
        ret = 0
        for consumer in self.items:
            if consumer.isElectricity:
                ret += consumer.quartWatts
        return ret

    def dailyWatts(self) -> int:
        ret = 0
        for consumer in self.items:
            if consumer.isElectricity:
                ret += consumer.dailyWatts
        return ret

    def quartCents(self) -> float:
        ret = float(0.0)

        for consumer in self.items:
            if consumer.isElectricity:
                ret += consumer.quartCents
        return ret

    def dailyCents(self):
        ret = float(0.0)
        for consumer in self.items:
            if consumer.isElectricity:
                ret += consumer.dailyCents
        return ret

class QuartControl():
    def __init__(self) -> None:
        self.priceTs = 0
        self.netTs = 0

    def setPriceTs(self, ts : int) -> None:
        print(datetime.utcnow(),'setting priceTs')
        self.priceTs = ts

    def setNetTs(self, ts : int) -> None:
        print(datetime.utcnow(),'setting netTs')
        self.netTs = ts

    def isChanged(self) -> bool:
        diff = abs(self.priceTs - self.netTs)
        if diff < 20:
            print(datetime.utcnow(),'quart change is ready, diff is', diff)
            return True
        return False


quartControl = QuartControl()
pricing = Pricing()
# ----------------------name--------steps--power-basepwr-pricecalc ----
thermostat  = Consumer("thermostat",   29,   600, 0, pricing.buyPrice)
stockheater = Consumer("stockheat",     1,  4000, 0, pricing.buyPrice)
solheater   = Consumer("solheat",       1,  2000, 0, pricing.surplusPrice)
storefridge = Consumer("sfridge",       1,    80, 0, pricing.buyPrice)
carheater   = Consumer("carheater",  2000,  2000, 0, pricing.buyPrice)
heatpump    = Consumer("heatpump",   2000,  2000, 0, pricing.buyPrice)
# burner will not be calculated to the sum of electricity consumers.
burner      = Consumer("burner",        1, 20800, 0, pricing.oilPrice, False) # 0.6gal/h = 2.27L/h -> 0.92 * 2.27 * 10 -> 20.8kw/h
allOther    = Consumer("other",         1,     0, 0, pricing.buyPrice)

solar       = SolarProduction()
elProduction  = ElProduction()

quartCalcPending = False
started = int(time())

consumers = Consumers((thermostat,
                       stockheater,
                       solheater,
                       storefridge,
                       carheater,
                       heatpump,
                       allOther,
                       burner))


def calcQuartChange(newTs : int) -> None:
    # netto is the value read from electricity meter, it can be negativi
    # or positive = production is bigger than consumption
    netto = elProduction.quartChanged()  # this comes from electricity metering
    if netto > 0:
        creditedW = round(solar.quartKw * 1000 * 4) - netto
        otherConsumptionW = creditedW - (consumers.quartWatts())
        otherCents = round((otherConsumptionW / 1000) * pricing.buyPrice(),2)
        allOther.setQuartPower(otherConsumptionW, newTs)
        print(datetime.utcnow(),'All the other consumption is', round(otherConsumptionW), 'W', otherCents, 'cents')
        creditedCents = round((creditedW / 4000) * pricing.buyPrice(),2)
        print(datetime.utcnow(),'credited solar production is', creditedW, 'W', creditedCents, 'cents')
        print(datetime.utcnow(),'Sold solar production is', netto,'W,',round(pricing.sellPrice() * netto / 1000,1),'cents.')
        consumers.totals(solar.quartKw , netto, creditedW / 4)
    else:
        creditedW = 0
        creditedCents = 0
        # -1 * (netto -700 + 1072)
        otherConsumptionW = round(-1 * (netto - round(solar.quartKw * 1000 * 4) + consumers.quartWatts()))
        print(datetime.utcnow(), "netto=", netto, "solar=", round(solar.quartKw * 1000 * 4), "consumers=", consumers.quartWatts())

        # vuorokauden vaihtumisen jÃ¤lkeen saattaa creditdW olla nolla mutta creditedCents positiivinen ??
        if solar.quartKw != 0.0:
            creditedW = round(solar.quartKw * 1000 * 4)
            creditedCents = round(solar.quartKw * pricing.buyPrice(),2)

        consumers.totals(solar.quartKw , 0, creditedW / 4)
        print(datetime.utcnow(),"Known consumers consumed:",round(consumers.quartWatts()),"price:", round(consumers.quartCents(),1))
        allOther.setQuartPower(otherConsumptionW, newTs)
        otherCents = round((otherConsumptionW / 1000) * pricing.buyPrice(),2)
        print(datetime.utcnow(),'Credited solar production is', creditedW, 'W', creditedCents, 'cents')
        print(datetime.utcnow(),'All the other consumption is', round(otherConsumptionW), 'W', otherCents, 'cents')
    solar.quartChanged(newTs)


def isDayChanged(ts : int) -> bool:
    tm = localtime(ts)
    return tm.tm_hour == 0 and tm.tm_min < 5


def processData(mqttdata) -> None:
    global subtopic, started

    indata = json.loads(mqttdata.payload)

    id = indata['id']
    if id == 'pmeter':
        print(datetime.utcnow(),"received heatpump power")
        heatpump.update(int(indata['power']), int(indata['ts']))

    if id == 'heatsetup':
        print(datetime.utcnow(),"received prices",indata['eltransferprice'], indata['elprice'],"heatoil",indata['heatoilprice'])
        print(datetime.utcnow(), "buy commission",indata['elprice'],"sell commission",indata['elselcommission'])
        pricing.setup(float(indata['eltransferprice']), float(indata['elprice']), float(indata['elselcommission']), float(indata['heatoilprice']))

    elif id == 'predailycalc':
        print(datetime.utcnow(),"Reading predaily sums from the topic.")
        solarW = int(indata['solarW'])
        consumers.setDailies(solarW, int(indata['soldW']), float(indata['soldCents']), int(indata['creditedW']),int(indata['creditedCents']))
        solar.prevSample = round(solarW / 1000, 2)
        for item in indata['consumers']:
            consumer = consumers.getConsumer(item['name'])
            print(datetime.utcnow(),"Reading consumer", item['name'], "start values from the topic.")
            consumer.setDailies(item['watts'], item['cents'])
        client.unsubscribe(mqtt_broker.topic_prefix + subtopic + "predaily")

    elif id == 'thermostat':
        newTs = int(indata['ts'])
        if newTs == 0:
            newTs = int(time())
        thermostat.update(int(indata['value']), newTs)

    elif id == 'cooler':
        newTs = int(indata['ts'])
        if newTs == 0:
            newTs = int(time())
        storefridge.update(int(indata['value']), newTs)

    elif id == 'state':
        if indata['sensor'] == 33:
            newTs = int(indata['ts'])
            if newTs == 0:
                newTs = int(time())
            burner.update(int(indata['value']), newTs)

    # handle devices which dropped out.
    elif id == 'device' and indata['connected'] == 0:
        newTs = int(time()) # data does not have a timestamp
        if indata['type'] == 'thermostat':
            thermostat.update(0, newTs)

    elif id == 'solarpower':
        solar.update(indata['energy_today'])

    elif id == 'relay':
        contact = int(indata['contact'])
        devname = indata['device']
        newTs = int(indata['ts'])
        if newTs == 0:
            newTs = int(time())
        if devname == 'shelly1':
            if contact == 0: # solar energy heating
                state = indata['state']
                level = 0
                if state:
                    level = 1
                solheater.update(level, newTs) # solheater starts only when there is enough solar energy


            elif contact == 2: # stock electricity heating
                state = indata['state']
                level = 0
                if state:
                    level = 1
                stockheater.update(level, newTs)

        elif devname == 'shellyplus1pm':
            if contact == 0: # carheater
                state = indata['state']
                power = int(indata['power'])
                carheater.update(power, newTs)

    elif id == 'power15min':
        newTs = int(indata['ts'])
        if newTs == 0:
            newTs = int(time())
        elProduction.update(indata['W15min'], newTs)
        quartControl.setNetTs(newTs)

        if quartControl.isChanged():
            print(datetime.utcnow(),"The calculations are done with buyprice", round(pricing.buyPrice(),2), "and sellprice", round(pricing.sellPrice(),2))
            calcQuartChange(newTs)
            consumers.quartChanged(newTs)
            if newTs - started > 15:
                consumers.publishQuartChange(newTs)
                consumers.publishDayChange(newTs, 'predaily')

            if isDayChanged(newTs):
                consumers.publishDayChange(newTs, 'daily')
                solar.reset()
                consumers.reset(True)
                elProduction.reset(True)
            else:
                consumers.reset(False)
                elProduction.reset(False)
            pricing.commitPrice(newTs)
            print("---------------------------------------------------------")

    # elprice/current topic changes just after the quart has been changed.
    # this triggers many calculations and printing/topic updates.
    elif id == 'elprice':
        newTs = int(indata['ts'])
        pricing.update(float(indata['price']), float(indata['notax']), newTs)
        quartControl.setPriceTs(newTs)

        if quartControl.isChanged():
            print(datetime.utcnow(),"The calculations are done with buyprice", round(pricing.buyPrice(),2), "and sellprice", round(pricing.sellPrice(),2))
            print(datetime.utcnow(),"elProduction sample age is", elProduction.sampleAge(),'sec.')
            calcQuartChange(newTs)
            consumers.quartChanged(newTs)
            if newTs - started > 15:
                consumers.publishQuartChange(newTs)
                consumers.publishDayChange(newTs, 'predaily')
            if isDayChanged(newTs):
                consumers.publishDayChange(newTs,'daily')
                print(datetime.utcnow(),"Total daily watts consumed:",consumers.dailyWatts(),"price:", consumers.dailyCents())
                solar.reset()
                consumers.reset(True)
                elProduction.reset(True)
            else:
                consumers.reset(False)
                elProduction.reset(False)
            pricing.commitPrice(newTs)
            print("---------------------------------------------------------")


def on_message(client, userdata, message):
    msgqueue.put(message)


def on_connect(client, userdata, flags, rc):
    global connected

    if (rc==0):
        connected = True
    else:
        print(datetime.utcnow(),"connection failed, rc=",rc)
        connected = False


def on_disconnect(client, userdata, rc):
    print(datetime.utcnow(),"disconnected")
    if rc != 7:
        try:
            client.reconnect()
        except:
            print(datetime.utcnow(),"reconnect failed, waiting...")
            sleep(30)
    else:
        sleep(1)


def on_publish(client, userdata,result):
    pass

msgqueue = Queue(maxsize=10)

client = mqtt.Client('calculator' + str(getpid()))
client.on_connect = on_connect
client.on_message = on_message
client.on_publish = on_publish

client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()



topics = [(mqtt_broker.topic_prefix + subtopic + "predaily",0),
          (mqtt_broker.topic_prefix + "/thermostat/+/parameters/level",0),
          (mqtt_broker.topic_prefix + "/heating/setup",0),
          (mqtt_broker.topic_prefix + "/sensors/5bcae4/parameters/state/#",0),
          (mqtt_broker.topic_prefix + "/refrigerator/fd9030/parameters/state/#",0),
          (mqtt_broker.topic_prefix + "/110782219170385/solarpower",0),
          (mqtt_broker.topic_prefix + "/relay/+/shelly1/state",0),
          (mqtt_broker.topic_prefix + "/relay/0/shellyplus1pm/state",0),
          (mqtt_broker.topic_prefix + "/phase/all/quarterhnet",0),
          (mqtt_broker.topic_prefix + "/devices/#",0),
          (mqtt_broker.topic_prefix + "/pmeter/shellypmminig3-heatpump/data",0),
          (mqtt_broker.topic_prefix + "/elprice/currentquart",0)]
client.subscribe(topics)

while True:
    try:
        data = msgqueue.get(block=True)
        if data is None:
            continue
        processData(data)

    except KeyboardInterrupt:
        client.disconnect()
        exit(0)

    except json.decoder.JSONDecodeError as e:
        print(datetime.utcnow(), "json:", e)
        print(datetime.utcnow(), data)

    except:
        raise
