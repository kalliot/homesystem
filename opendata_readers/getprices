#!/usr/bin/env python

import time
from datetime import datetime
import urllib.request
import urllib.error
import requests
import os
import json
import sys
import pytz
import paho.mqtt.client as mqtt 
import paho.mqtt.subscribe as subscribe

sys.path.insert(1, '/home/pi/config')
from setup import nordpool, mqtt_broker


class priceStats:
    def __init__(self, data, overPrice):
        self.min  = 120
        self.max  = -20
        self.avg  = 0

        hourCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        # first find out min,max and avg from those which are not overpriced.
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - 3600)):
                hourCnt += 1
                if hourCnt > 24:
                    break
                price = round(float(hour['PriceWithTax']) * 100, 2)
                if price < overPrice:
                    cnt += 1
                    sum = sum + price
                    if (price < self.min):
                        self.min = price
                    if (price > self.max):
                        self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt



def on_message(client, userdata, message):
    print(message.payload)


def logger(client, userdata, level, buff):
    print("level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.now(),"connection failed, rc=",rc)       
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client,userdata,result):
    pass

def publishError(code, reason):
    now = int(time.time())

    jsonRec = {
        "id"      :      "nordpoolerror",
        "dev"     :      "spot-hinta",
        "ts"      :      now,
        "category":      "http",
        "code"    :      code,
        "description" :  reason
    }
    topic = mqtt_broker.topic_prefix + "/error/elprice"
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish of error failed")


def strTime(dateTime):
    ts = int(datetime.fromisoformat(dateTime).timestamp())
    return datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H")



def findBoostHours(data, overPrice):
    stats = priceStats(data, overPrice)
    hourCnt = 0
    cnt     = 0
    price   = 0.0
    prevprice = 0.0
    times, prices, reasons = [], [], []

    print(datetime.now(),"stats, min", stats.min, "max", stats.max, "avg", stats.avg)

    for hour in data:
        ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
        if (ts > (now - 3600)):
            hourCnt += 1
            if hourCnt > 24:
                break
            price = round(float(hour['PriceWithTax']) * 100.0,2)

            # minimum is almost always acceptable
            # it cannot be the last, because we don't yet
            # know is it going to decrease more.
            if price == stats.min and hourCnt < 24:
                s = strTime(hour["DateTime"])
                times.append(s)
                reasons.append('min')
                prices.append(price)

            # climbing over average level.
            elif price > stats.avg and hourCnt > 1 and prevprice < stats.avg:
                s = strTime(data[cnt-1]['DateTime'])
                times.append(s)
                reasons.append('avg')
                prices.append(prevprice)

            #price is increasing.
            elif prevprice != 0 and (price / prevprice > 1.2):
                s = strTime(data[cnt-1]['DateTime'])
                times.append(s)
                reasons.append('inc')
                prices.append(prevprice)
            prevprice = price
        cnt += 1

    topic = mqtt_broker.topic_prefix + "/elprice/boosthours"
    result = {"id":"boosthours", "values": [{"time": t, "price": s, "reason": r} for t, s, r in zip(times, prices, reasons)]}
    client.publish(topic, json.dumps(result), qos=0, retain=True)

def queryCloud():

    try:
        data = requests.get(nordpool.BaseURL)

    except urllib.error.HTTPError  as e:
        ErrorInfo= e.read().decode()
        print('Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    except  urllib.error.URLError as e:
        ErrorInfo= e.read().decode()
        print('Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    return data


# todo: what if topic heating/setup is empty?
m = subscribe.simple(mqtt_broker.topic_prefix + "/heating/setup", hostname=mqtt_broker.address, msg_count=1)
data = json.loads(m.payload)

if data['eltype'] == 'stock':
    stock_commission = float(data['elprice'])
else:
    stock_commission = 0.25

pricelimit = float(data['heatoilprice']) * 10 - float(data['eltransferprice']) - stock_commission

pid = os.getpid()
client = mqtt.Client("nordpool reader" + str(pid)) #create new instance
client.on_connect = on_connect
client.on_message=on_message
client.on_publish=on_publish
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.now(), "Start")
client.loop_start()

cnt = 0

for i in range(3):
    x = queryCloud()

    data = x.json()
    if x.status_code == 200:
        now = int(time.time())
        findBoostHours(data, pricelimit) # heating oil price - transfer - commission from stock price
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - 3600)):
                cnt = cnt +1
                if (cnt > 24):
                    break

                cents = round(float(hour['PriceWithTax']) * 100,2)
                centsNoTax = round(float(hour['PriceNoTax']) * 100, 2)
                strhour=datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%H")
                topic = mqtt_broker.topic_prefix + "/elprice/" + strhour

                send_msg = {
                        'id': 'elprice',
                        'hour': strhour,
                        'ts': ts,
                        'day': datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H"),
                        'price': cents,
                        'notax': centsNoTax
                }

                msg = json.dumps(send_msg)
                client.publish(topic, msg, qos=0, retain=True)
        break

    else:
        publishError(x.status_code, x.reason)
        time.sleep(10)

print(datetime.now(),"done.")