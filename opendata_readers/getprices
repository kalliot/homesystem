#!/usr/bin/env python

import time
from datetime import datetime
import urllib.request
import urllib.error
import requests
import os
import json
import sys
import pytz
import paho.mqtt.client as mqtt 

sys.path.insert(1, '/home/pi/config')
from setup import nordpool, mqtt_broker

pricelimit = 1.0 # if no setup is got, this is so low, that no boosthours are generated
compressor_pricelimit = 1.0
priceratio = 0.95

class priceStats:
    def __init__(self, data, overPrice, start, maxcnt):
        self.min  = 320
        self.max  = -20
        self.avg  = 0

        hourCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        # first find out min,max and avg from those which are not overpriced.
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - start * 3600)):
                hourCnt += 1
                if hourCnt > maxcnt:
                    break
                price = round(float(hour['PriceWithTax']) * 100, 2)
                if price < overPrice:
                    cnt += 1
                    sum = sum + price
                    if (price < self.min):
                        self.min = price
                    if (price > self.max):
                        self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt



def on_message(client, userdata, message):
    global pricelimit,compressor_pricelimit

    stock_commission = 0.25

    data = json.loads(message.payload)
    if data['eltype'] == 'stock':
        stock_commission = float(data['elprice'])

    pricelimit = float(data['heatoilprice']) * 10 - float(data['eltransferprice']) - stock_commission
    compressor_pricelimit = float(data['heatoilprice']) * 30 - float(data['eltransferprice']) - stock_commission


def logger(client, userdata, level, buff):
    print(datetime.now(),"level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.now(),"connection failed, rc=",rc)       
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client,userdata,result):
    pass

def publishError(code, reason):
    now = int(time.time())

    jsonRec = {
        "id"      :      "nordpoolerror",
        "dev"     :      "spot-hinta",
        "ts"      :      now,
        "category":      "http",
        "code"    :      code,
        "description" :  reason
    }
    topic = mqtt_broker.topic_prefix + "/error/elprice"
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish of error failed")


def strTime(dateTime):
    ts = int(datetime.fromisoformat(dateTime).timestamp())
    return datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H")


def findHeatPumpCheapHours(data, overPrice):
    hourCnt = 0
    cnt     = 0
    price   = 0.0
    prevprice = 0.0
    times, prices, reasons, tstamps = [], [], [], []

    datalen = len(data)
    print(datetime.now(),"datalen=",datalen, "pricelimit=", overPrice)

    for hour in data:
        ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
        if (ts > (now - 5 * 3600)):
            hourCnt += 1
            price = round(float(hour['PriceWithTax']) * 100.0,2)
            if cnt < datalen-1:
                nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
            else:
                nextprice = price

            if prevprice != 0:
                if price == 0:
                    prevPriceratio = 0.001 / prevprice
                else:
                    prevPriceratio = price /  prevprice

            if nextprice != 0:
                if price == 0:
                    nextPriceRatio = 0.001 / nextprice
                else:
                    nextPriceRatio = price / nextprice

            if price < overPrice and prevprice > price and nextprice > price:
                if (prevPriceratio > priceratio):
                    s = strTime(data[cnt-1]['DateTime'])
                    if not s in times:
                        times.append(s)
                        tstamps.append(ts-3600)
                        reasons.append('beforebottom')
                        prices.append(prevprice)

                s = strTime(hour["DateTime"])
                if not s in times:
                    times.append(s)
                    reasons.append('bottom')
                    tstamps.append(ts)
                    prices.append(price)

                if nextPriceRatio > priceratio and cnt+1 < datalen:
                    s = strTime(data[cnt+1]['DateTime'])
                    if not s in times:
                        times.append(s)
                        tstamps.append(ts+3600)
                        reasons.append('afterbottom')
                        prices.append(nextprice)

            prevprice = price
        cnt += 1

    topic = mqtt_broker.topic_prefix + "/elprice/awhightemp"
    result = {
                "id":"awhightemp", "ts": int(time.time()), "values": [
                    {"ts": ts, "time": t, "price": s, "reason": r} for ts, t, s, r in zip(tstamps, times, prices, reasons)
                ]
             }
    client.publish(topic, json.dumps(result), qos=0, retain=True)


def findHeatPumpExpensiveHours(data, overPrice):
    hourCnt = 0
    cnt     = 0
    price   = 0.0
    times, prices, reasons, tstamps = [], [], [], []

    prevprice = round(float(data[0]['PriceWithTax']) * 100.0,2)
    datalen = len(data)

    for hour in data:
        ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
        if (ts > (now - 5 * 3600)):
            hourCnt += 1
            price = round(float(hour['PriceWithTax']) * 100.0,2)
            if (price < overPrice):
                if cnt < datalen-1:
                    nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
                else:
                    nextprice = price

                if prevprice != 0:
                    if price == 0:
                        prevPriceratio = prevprice / 0.001
                    else:
                        prevPriceratio = prevprice / price

                if nextprice != 0:
                    if price == 0:
                        nextPriceRatio = nextprice / 0.001
                    else:
                        nextPriceRatio = nextprice / price

                # top of the price hill and it's neighbors.
                if prevprice < price and nextprice < price:
                    if (prevPriceratio > priceratio):
                        s = strTime(data[cnt-1]['DateTime'])
                        if not s in times:
                            times.append(s)
                            tstamps.append(ts-3600)
                            reasons.append('beforetop')
                            prices.append(prevprice)

                    s = strTime(hour["DateTime"])
                    if not s in times:
                        times.append(s)
                        reasons.append('top')
                        tstamps.append(ts)
                        prices.append(price)

                    if nextPriceRatio > priceratio and cnt+1 < datalen:
                        s = strTime(data[cnt+1]['DateTime'])
                        if not s in times:
                            times.append(s)
                            tstamps.append(ts+3600)
                            reasons.append('aftertop')
                            prices.append(nextprice)

            prevprice = price
        cnt += 1

    topic = mqtt_broker.topic_prefix + "/elprice/awlowtemp"
    result = {
                "id":"awlowtemp", "ts": int(time.time()), "values": [
                    {"ts": ts, "time": t, "price": s, "reason": r} for ts, t, s, r in zip(tstamps, times, prices, reasons)
                ]
             }
    client.publish(topic, json.dumps(result), qos=0, retain=True)



def findBoostHours(data, overPrice):
    stats = priceStats(data, overPrice, 1, 24)
    hourCnt = 0
    cnt     = 0
    price   = 0.0
    prevprice = 0.0
    times, prices, reasons, tstamps = [], [], [], []

    print(datetime.utcnow(),"stats, min", stats.min, "max", stats.max, "avg", stats.avg)

    for hour in data:
        ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
        if (ts > (now - 3600)):
            hourCnt += 1
            if hourCnt > 24:
                break
            price = round(float(hour['PriceWithTax']) * 100.0,2)

            # minimum is almost always acceptable
            # it cannot be the last, because we don't yet
            # know is it going to decrease more.
            if price < overPrice and price == stats.min and hourCnt < 24:
                s = strTime(hour["DateTime"])
                times.append(s)
                reasons.append('min')
                tstamps.append(ts)
                prices.append(price)

            # climbing over average level.
            elif prevprice < overPrice and price > stats.avg and hourCnt > 1 and prevprice < stats.avg:
                s = strTime(data[cnt-1]['DateTime'])
                if not s in times:
                    times.append(s)
                    tstamps.append(ts)
                    reasons.append('avg')
                    prices.append(prevprice)

            #price is increasing.
            elif prevprice < overPrice and prevprice != 0 and (price / prevprice > 1.2):
                s = strTime(data[cnt-1]['DateTime'])
                if not s in times:
                    times.append(s)
                    tstamps.append(ts)
                    reasons.append('inc')
                    prices.append(prevprice)
            prevprice = price
        cnt += 1

    topic = mqtt_broker.topic_prefix + "/elprice/boosthours"
    result = {"id":"boosthours", "ts": int(time.time()), "values": [{"ts": ts, "time": t, "price": s, "reason": r} for ts, t, s, r in zip(tstamps, times, prices, reasons)]}
    client.publish(topic, json.dumps(result), qos=0, retain=True)

def queryCloud():

    try:
        data = requests.get(nordpool.BaseURL)

    except urllib.error.HTTPError  as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    except  urllib.error.URLError as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    return data



pid = os.getpid()
client = mqtt.Client("nordpool reader" + str(pid)) #create new instance
client.on_connect = on_connect
client.on_message=on_message
client.on_publish=on_publish
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()
client.subscribe(mqtt_broker.topic_prefix + "/heating/setup")

# wait to get setup before query.
time.sleep(1)

cnt = 0
for i in range(3):
    x = queryCloud()

    data = x.json()
    if x.status_code == 200:
        now = int(time.time())
        findBoostHours(data, pricelimit) # heating oil price - transfer - commission from stock price
        findHeatPumpCheapHours(data, compressor_pricelimit)
        findHeatPumpExpensiveHours(data, compressor_pricelimit)
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - 3600)):
                cnt = cnt +1
                if (cnt > 24):
                    break

                cents = round(float(hour['PriceWithTax']) * 100,2)
                centsNoTax = round(float(hour['PriceNoTax']) * 100, 2)
                strhour=datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%H")
                topic = mqtt_broker.topic_prefix + "/elprice/" + strhour

                send_msg = {
                        'id': 'elprice',
                        'hour': strhour,
                        'ts': ts,
                        'day': datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H"),
                        'price': cents,
                        'notax': centsNoTax
                }

                msg = json.dumps(send_msg)
                client.publish(topic, msg, qos=0, retain=True)
        break

    else:
        publishError(x.status_code, x.reason)
        time.sleep(10)

print(datetime.utcnow(),"done.")