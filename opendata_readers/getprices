#!/usr/bin/env python

import time
from datetime import datetime
import urllib.request
import urllib.error
import requests
import os
import json
import sys
import pytz
import paho.mqtt.client as mqtt 
import paho.mqtt.subscribe as subscribe

sys.path.insert(1, '/home/pi/config')
from setup import nordpool, mqtt_broker

pricelimit = 1.0 # if no setup is got, this is so low, that no boosthours are generated

class priceStats:
    def __init__(self, data, overPrice):
        self.min  = 120
        self.max  = -20
        self.avg  = 0

        hourCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        # first find out min,max and avg from those which are not overpriced.
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - 3600)):
                hourCnt += 1
                if hourCnt > 24:
                    break
                price = round(float(hour['PriceWithTax']) * 100, 2)
                if price < overPrice:
                    cnt += 1
                    sum = sum + price
                    if (price < self.min):
                        self.min = price
                    if (price > self.max):
                        self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt



def on_message(client, userdata, message):
    global pricelimit

    stock_commission = 0.25

    data = json.loads(message.payload)
    if data['eltype'] == 'stock':
        stock_commission = float(data['elprice'])

    pricelimit = float(data['heatoilprice']) * 10 - float(data['eltransferprice']) - stock_commission



def logger(client, userdata, level, buff):
    print("level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.now(),"connection failed, rc=",rc)       
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client,userdata,result):
    pass

def publishError(code, reason):
    now = int(time.time())

    jsonRec = {
        "id"      :      "nordpoolerror",
        "dev"     :      "spot-hinta",
        "ts"      :      now,
        "category":      "http",
        "code"    :      code,
        "description" :  reason
    }
    topic = mqtt_broker.topic_prefix + "/error/elprice"
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish of error failed")


def strTime(dateTime):
    ts = int(datetime.fromisoformat(dateTime).timestamp())
    return datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H")



def findBoostHours(data, overPrice):
    stats = priceStats(data, overPrice)
    hourCnt = 0
    cnt     = 0
    price   = 0.0
    prevprice = 0.0
    times, prices, reasons, tstamps = [], [], [], []

    print(datetime.now(),"stats, min", stats.min, "max", stats.max, "avg", stats.avg)

    for hour in data:
        ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
        if (ts > (now - 3600)):
            hourCnt += 1
            if hourCnt > 24:
                break
            price = round(float(hour['PriceWithTax']) * 100.0,2)

            # minimum is almost always acceptable
            # it cannot be the last, because we don't yet
            # know is it going to decrease more.
            if price < overPrice and price == stats.min and hourCnt < 24:
                s = strTime(hour["DateTime"])
                times.append(s)
                reasons.append('min')
                tstamps.append(ts)
                prices.append(price)

            # climbing over average level.
            elif prevprice < overPrice and price > stats.avg and hourCnt > 1 and prevprice < stats.avg:
                s = strTime(data[cnt-1]['DateTime'])
                if not s in times:
                    times.append(s)
                    tstamps.append(ts)
                    reasons.append('avg')
                    prices.append(prevprice)

            #price is increasing.
            elif prevprice < overPrice and prevprice != 0 and (price / prevprice > 1.2):
                s = strTime(data[cnt-1]['DateTime'])
                if not s in times:
                    times.append(s)
                    tstamps.append(ts)
                    reasons.append('inc')
                    prices.append(prevprice)
            prevprice = price
        cnt += 1

    topic = mqtt_broker.topic_prefix + "/elprice/boosthours"
    result = {"id":"boosthours", "ts": int(time.time()), "values": [{"ts": ts, "time": t, "price": s, "reason": r} for ts, t, s, r in zip(tstamps, times, prices, reasons)]}
    client.publish(topic, json.dumps(result), qos=0, retain=True)

def queryCloud():

    try:
        data = requests.get(nordpool.BaseURL)

    except urllib.error.HTTPError  as e:
        ErrorInfo= e.read().decode()
        print('Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    except  urllib.error.URLError as e:
        ErrorInfo= e.read().decode()
        print('Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    return data



pid = os.getpid()
client = mqtt.Client("nordpool reader" + str(pid)) #create new instance
client.on_connect = on_connect
client.on_message=on_message
client.on_publish=on_publish
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.now(), "Start")
client.loop_start()
client.subscribe(mqtt_broker.topic_prefix + "/heating/setup")

# wait to get setup before query.
time.sleep(1)

cnt = 0
for i in range(3):
    x = queryCloud()

    data = x.json()
    if x.status_code == 200:
        now = int(time.time())
        findBoostHours(data, pricelimit) # heating oil price - transfer - commission from stock price
        for hour in data:
            ts = int(datetime.fromisoformat(hour['DateTime']).timestamp())
            if (ts > (now - 3600)):
                cnt = cnt +1
                if (cnt > 24):
                    break

                cents = round(float(hour['PriceWithTax']) * 100,2)
                centsNoTax = round(float(hour['PriceNoTax']) * 100, 2)
                strhour=datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%H")
                topic = mqtt_broker.topic_prefix + "/elprice/" + strhour

                send_msg = {
                        'id': 'elprice',
                        'hour': strhour,
                        'ts': ts,
                        'day': datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H"),
                        'price': cents,
                        'notax': centsNoTax
                }

                msg = json.dumps(send_msg)
                client.publish(topic, msg, qos=0, retain=True)
        break

    else:
        publishError(x.status_code, x.reason)
        time.sleep(10)

print(datetime.now(),"done.")