#!/usr/bin/env python

import time
from datetime import datetime
import urllib.request
import urllib.error
import requests
import os
import json
import sys
import pytz
import paho.mqtt.client as mqtt 

sys.path.insert(1, '/home/pi/config')
from setup import nordpool, mqtt_broker

pricelimit = 1.0 # if no setup is got, this is so low, that no boostquarts are generated
compressor_pricelimit = 1.0
priceratio = 0.95

class priceStats:
    def __init__(self, data, start, maxcnt):
        self.min  = 320
        self.max  = -20
        self.avg  = 0

        qCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        # first find out min,max and avg from those which are not overpriced.
        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if (ts > (now - start * 3600)):
                qCnt += 1
                if qCnt > maxcnt:
                    break
                price = round(float(quart['PriceWithTax']) * 100, 2)
                cnt += 1
                sum = sum + price
                if (price < self.min):
                    self.min = price
                if (price > self.max):
                    self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt



def on_message(client, userdata, message):
    pass


def logger(client, userdata, level, buff):
    print(datetime.now(),"level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.now(),"connection failed, rc=",rc)       
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client,userdata,result):
    pass

def publishError(code, reason):
    now = int(time.time())

    jsonRec = {
        "id"      :      "nordpoolerror",
        "dev"     :      "spot-hinta",
        "ts"      :      now,
        "category":      "http",
        "code"    :      code,
        "description" :  reason
    }
    topic = mqtt_broker.topic_prefix + "/error/elprice"
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish of error failed")


def strTime(dateTime):
    ts = int(datetime.fromisoformat(dateTime).timestamp())
    return datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H%M")

class specialQuart():
    def __init__(self, name):
        self.name = name
        self.times = []
        self.prices = []
        self.reasons = []
        self.tstamps = []
        self.count = 0

    def exists(self, strtime):
        for i in range(self.count):
            if (self.times[i] == strtime):
                return True
        return False


    def addRec(self, strtime,price,reason,tstamp):
        if not strtime in self.times:
            self.times.append(strtime)
            self.prices.append(price)
            self.reasons.append(reason)
            self.tstamps.append(tstamp)
            self.count += 1
        else:
            print("did not add, it already exists", strtime,"price", price)

    def delRec(self, strtime):
        for i in range(self.count):
            try:
                if (self.times[i] == strtime):
                    self.times.pop(i)
                    self.prices.pop(i)
                    self.reasons.pop(i)
                    self.tstamps.pop(i)
                    self.count -= 1
                    break

            except IndexError:
                return

    def clear(self, name):
        for i in range(self.count):
            try:
                if self.reasons[i] != name:
                    print("removing time", self.times[i])
                    self.times.pop(i)
                    self.prices.pop(i)
                    self.reasons.pop(i)
                    self.tstamps.pop(i)
                    self.count -= 1

            except IndexError:
                return


cheapQuarts     = specialQuart("awhightemp")
expensiveQuarts = specialQuart("awlowtemp")


def findCheapQuartsByRank(data, maxrank):
    now = int(time.time())

    for quart in data:
        ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
        if (ts > (now - 3 * 3600)):
            rank = int(quart['Rank'])

            if rank < maxrank +1:
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                cheapQuarts.addRec(strTime(quart['DateTime']),price,'cheaprank',ts)
                print("adding cheap quart",quart['DateTime'], "by rank, price is", price)


def findExpensiveQuartsByRank(data, minrank):
    now = int(time.time())

    for quart in data:
        ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
        if (ts > (now - 3 * 3600)):
            rank = int(quart['Rank'])

            if rank > minrank -1:
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if price > 1.0:
                    expensiveQuarts.addRec(strTime(quart['DateTime']),price,'expensiverank',ts)
                    print("adding expensive quart",quart['DateTime'], "by rank, price is", price)


def findScatteredExpensiveQuarts(data):
    global priceratio
    adder = 0.05
    now = int(time.time())

    for i in range(32):
        cnt     = 0
        price   = 0.0
        nextPriceRatio = priceratio - 0.5
        prevPriceRatio = priceratio - 0.5
        expensiveCnt = 0

        prevprice = round(float(data[0]['PriceWithTax']) * 100.0,2)
        datalen = len(data)

        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if ts > (now - 5 * 3600):
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if cnt < datalen-1:
                    nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
                else:
                    nextprice = price

                if prevprice != 0:
                    if price == 0:
                        prevPriceRatio = prevprice / 0.001
                    else:
                        prevPriceRatio = prevprice / price

                if nextprice != 0:
                    if price == 0:
                        nextPriceRatio = nextprice / 0.001
                    else:
                        nextPriceRatio = nextprice / price

                # top of the price hill and it's neighbors.
                if prevprice + adder < price and nextprice + adder < price:  # this is a hilltop
                    if (prevPriceRatio > priceratio):
                        expensiveQuarts.addRec(strTime(data[cnt-1]['DateTime']),prevprice,'beforetop',ts-900)
                    expensiveQuarts.addRec(strTime(quart['DateTime']),price,'top',ts)

                    if nextPriceRatio > priceratio and cnt+1 < datalen:
                        expensiveQuarts.addRec(strTime(data[cnt+1]['DateTime']),nextprice,'aftertop',ts+900)
                    expensiveCnt += 1
                prevprice = price
            cnt += 1
        if expensiveCnt < 24:
            print("expensivecount was only", expensiveCnt, "breaking")
            break
        else:
            adder += 0.1
            expensiveQuarts.clear("expensiverank")



def findScatteredCheapQuarts(data):
    global priceratio
    adder = -0.05
    now = int(time.time())


    for i in range(32):
        cnt     = 0
        price   = 0.0
        prevprice = 0.0
        nextPriceRatio = priceratio - 0.5
        prevPriceRatio = priceratio - 0.5
        cheapCnt = 0

        datalen = len(data)
        print(datetime.now(),"datalen=",datalen)

        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if ts > (now - 5 * 3600):
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if cnt < datalen-1:
                    nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
                else:
                    nextprice = price

                if prevprice != 0:
                    if price == 0:
                        prevPriceRatio = 0.001 / prevprice
                    else:
                        prevPriceRatio = price /  prevprice

                if nextprice != 0:
                    if price == 0:
                        nextPriceRatio = 0.001 / nextprice
                    else:
                        nextPriceRatio = price / nextprice

                if prevprice + adder > price and nextprice + adder > price:  # this is a pit
                    if (prevPriceRatio > priceratio):
                        cheapQuarts.addRec(strTime(data[cnt-1]['DateTime']),prevprice,'beforebottom',ts-900)
                    cheapQuarts.addRec(strTime(quart['DateTime']),price,'bottom',ts)
                    if nextPriceRatio > priceratio and cnt+1 < datalen:
                        cheapQuarts.addRec(strTime(data[cnt+1]['DateTime']),nextprice,'afterbottom',ts+900)
                    cheapCnt += 1

                prevprice = price
            cnt += 1
        if cheapCnt < 24:
            print("cheapcount was only", cheapCnt, "breaking")
            break
        else:
            adder -= 0.1
            cheapQuarts.clear("cheaprank")



def removeDuplicates():
    if expensiveQuarts.count > cheapQuarts.count:
        for quart in cheapQuarts.times:
            expensiveQuarts.delRec(quart)

    if expensiveQuarts.count <= cheapQuarts.count:
        for quart in expensiveQuarts.times:
            cheapQuarts.delRec(quart)


def findDifferencies(data):
    stats = priceStats(data, 1, 96)

    print(datetime.utcnow(),"stats, min", stats.min, "max", stats.max, "avg", stats.avg)
    if stats.max - stats.min <= 2:
        return False

    return True


def queryCloud():

    try:
        data = requests.get(nordpool.BaseURL)

    except urllib.error.HTTPError  as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    except  urllib.error.URLError as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    return data



pid = os.getpid()
client = mqtt.Client("nordpool reader" + str(pid)) #create new instance
client.on_connect = on_connect
client.on_message=on_message
client.on_publish=on_publish
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()
client.subscribe(mqtt_broker.topic_prefix + "/heating/setup")

# wait to get setup before query.
time.sleep(1)

cnt = 0
for i in range(3):
    x = queryCloud()

    data = x.json()

    if x.status_code == 200:
        now = int(time.time())

        if (findDifferencies(data)):
            findCheapQuartsByRank(data, 16)     # where rank is less than 16.
            findExpensiveQuartsByRank(data, 80) # where rank is over 80 ie 16 most expensives.
            findScatteredCheapQuarts(data)
            findScatteredExpensiveQuarts(data)
            removeDuplicates()


        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if (ts > now):
                cnt = cnt +1
                if (cnt > 90):
                    break

                cents = round(float(quart['PriceWithTax']) * 100,2)
                centsNoTax = round(float(quart['PriceNoTax']) * 100, 2)
                strquart=datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%H%M")
                topic = mqtt_broker.topic_prefix + "/elprice/" + strquart
                day = datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H%M")

                if cents == 0:
                    pricestate = 'low'
                else:
                    pricestate = 'normal'

                    for cheaptime in cheapQuarts.times:
                        if cheaptime == day:
                            pricestate = 'low'
                            break

                    for cheaptime in expensiveQuarts.times:
                        if cheaptime == day:
                            pricestate = 'high'
                            break

                send_msg = {
                        'id': 'elprice',
                        'quart': strquart,
                        'ts': ts,
                        'day': day,
                        'pricestate': pricestate,
                        'price': cents,
                        'notax': centsNoTax
                }

                msg = json.dumps(send_msg)
                client.publish(topic, msg, qos=0, retain=True)
        break

    else:
        publishError(x.status_code, x.reason)
        time.sleep(10)

print(datetime.utcnow(),"done.")
