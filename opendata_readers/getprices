#!/usr/bin/env python

import time
from datetime import datetime
import urllib.request
import urllib.error
import requests
import os
import json
import sys
import pytz
import paho.mqtt.client as mqtt 

sys.path.insert(1, '/home/pi/config')
from setup import nordpool, mqtt_broker

pricelimit = 1.0 # if no setup is got, this is so low, that no boostquarts are generated
compressor_pricelimit = 1.0
priceratio = 0.95
filename = 'cloud'

class priceStats:
    def __init__(self, data, start, maxcnt):
        self.min  = 320
        self.max  = -20
        self.avg  = 0

        qCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        # first find out min,max and avg from those which are not overpriced.
        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if (ts > (now - start * 3600)):
                qCnt += 1
                if qCnt > maxcnt:
                    break
                price = round(float(quart['PriceWithTax']) * 100, 2)
                cnt += 1
                sum = sum + price
                if (price < self.min):
                    self.min = price
                if (price > self.max):
                    self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt

def dayNum(ts):
    return int(datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%w"))


class dayStats:
    def __init__(self, data, tomorrow):
        self.min  = 320
        self.max  = -20
        self.avg  = 0
        self.wday = -1
        self.available = False

        qCnt = 0
        cnt = 0
        sum = 0
        now = int(time.time())
        if tomorrow == True:
            now = now + 86400
        self.wday = dayNum(now)
        print("weekday is", self.wday)

        # first find out min,max and avg from those which are not overpriced.
        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            recDay = dayNum(ts + 7200)
            print("recday", recDay, quart['DateTime'])
            if self.wday == recDay:
                qCnt += 1
                price = round(float(quart['PriceWithTax']) * 100, 2)
                cnt += 1
                sum = sum + price
                if (price < self.min):
                    self.min = price
                if (price > self.max):
                    self.max = price

        if sum != 0 and cnt > 0:
            self.avg = sum / cnt
            self.available = True


def publisDayStats(min, max, avg, daynum):
    now = int(time.time())

    jsonRec = {
        "id"      :      "daystats",
        "weekday" :      daynum,
        "ts"      :      now,
        "min"     :      round(min,2),
        "max"     :      round(max,2),
        "avg"     :      round(avg,2)
    }
    topic = mqtt_broker.topic_prefix + "/elprice/daystats/" + str(daynum)
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish daystats failed")



def on_message(client, userdata, message):
    pass


def logger(client, userdata, level, buff):
    print(datetime.now(),"level=",level," buff=",buff)


def on_connect(client, userdata, flags, rc):
    global connected
    if (rc==0):
        connected = True
    else:
        print(datetime.now(),"connection failed, rc=",rc)       
        connected = False

def on_disconnect(client, userdata, rc):
    client.reconnect()

def on_publish(client,userdata,result):
    pass

def publishError(code, reason):
    now = int(time.time())

    jsonRec = {
        "id"      :      "nordpoolerror",
        "dev"     :      "spot-hinta",
        "ts"      :      now,
        "category":      "http",
        "code"    :      code,
        "description" :  reason
    }
    topic = mqtt_broker.topic_prefix + "/error/elprice"
    try:
        client.publish(topic, json.dumps(jsonRec), qos=0, retain=True)
    except:
        print(datetime.now(),"mqtt publish of error failed")


def strTime(dateTime):
    ts = int(datetime.fromisoformat(dateTime).timestamp())
    return datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H%M")

class specialQuart():
    def __init__(self, name):
        self.name = name
        self.times = []
        self.prices = []
        self.reasons = []
        self.tstamps = []
        self.count = 0

    def exists(self, strtime):
        for i in range(self.count):
            if (self.times[i] == strtime):
                return True
        return False


    def addRec(self, strtime,price,reason,tstamp):
        if not strtime in self.times:
            self.times.append(strtime)
            self.prices.append(price)
            self.reasons.append(reason)
            self.tstamps.append(tstamp)
            self.count += 1
        else:
            print("did not add, it already exists", strtime,"price", price)

    def delRec(self, strtime):
        for i in range(self.count):
            try:
                if (self.times[i] == strtime):
                    self.times.pop(i)
                    self.prices.pop(i)
                    self.reasons.pop(i)
                    self.tstamps.pop(i)
                    self.count -= 1
                    break

            except IndexError:
                return

    def clear(self, name):
        for i in range(self.count):
            try:
                if self.reasons[i] != name:
                    print("removing time", self.times[i])
                    self.times.pop(i)
                    self.prices.pop(i)
                    self.reasons.pop(i)
                    self.tstamps.pop(i)
                    self.count -= 1

            except IndexError:
                return


cheapQuarts     = specialQuart("awhightemp")
expensiveQuarts = specialQuart("awlowtemp")


def findCheapQuartsByRank(data, maxrank):
    now = int(time.time())

    for quart in data:
        ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
        if (ts > (now - 3 * 3600)):
            rank = int(quart['Rank'])

            if rank < maxrank +1:
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                cheapQuarts.addRec(strTime(quart['DateTime']),price,'cheaprank',ts)
                print("adding cheap quart",quart['DateTime'], "by rank, price is", price)


def findExpensiveQuartsByRank(data, minrank):
    now = int(time.time())

    for quart in data:
        ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
        if (ts > (now - 3 * 3600)):
            rank = int(quart['Rank'])

            if rank > minrank -1:
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if price > 1.0:
                    expensiveQuarts.addRec(strTime(quart['DateTime']),price,'expensiverank',ts)
                    print("adding expensive quart",quart['DateTime'], "by rank, price is", price)


def findScatteredExpensiveQuarts(data):
    global priceratio
    adder = 0.05
    now = int(time.time())

    for i in range(32):
        cnt     = 0
        price   = 0.0
        nextPriceRatio = priceratio - 0.5
        prevPriceRatio = priceratio - 0.5
        expensiveCnt = 0

        prevprice = round(float(data[0]['PriceWithTax']) * 100.0,2)
        datalen = len(data)

        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if ts > (now - 5 * 3600):
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if cnt < datalen-1:
                    nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
                else:
                    nextprice = price

                if prevprice != 0:
                    if price == 0:
                        prevPriceRatio = prevprice / 0.001
                    else:
                        prevPriceRatio = prevprice / price

                if nextprice != 0:
                    if price == 0:
                        nextPriceRatio = nextprice / 0.001
                    else:
                        nextPriceRatio = nextprice / price

                # top of the price hill and it's neighbors.
                if prevprice + adder < price and nextprice + adder < price:  # this is a hilltop
                    if (prevPriceRatio > priceratio):
                        expensiveQuarts.addRec(strTime(data[cnt-1]['DateTime']),prevprice,'beforetop',ts-900)
                    expensiveQuarts.addRec(strTime(quart['DateTime']),price,'top',ts)

                    if nextPriceRatio > priceratio and cnt+1 < datalen:
                        expensiveQuarts.addRec(strTime(data[cnt+1]['DateTime']),nextprice,'aftertop',ts+900)
                    expensiveCnt += 1
                prevprice = price
            cnt += 1
        if expensiveCnt < 24:
            print("expensivecount was only", expensiveCnt, "breaking")
            break
        else:
            adder += 0.1
            expensiveQuarts.clear("expensiverank")



def findScatteredCheapQuarts(data):
    global priceratio
    adder = -0.05
    now = int(time.time())


    for i in range(32):
        cnt     = 0
        price   = 0.0
        prevprice = 0.0
        nextPriceRatio = priceratio - 0.5
        prevPriceRatio = priceratio - 0.5
        cheapCnt = 0

        datalen = len(data)
        print(datetime.now(),"datalen=",datalen)

        for quart in data:
            ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
            if ts > (now - 5 * 3600):
                price = round(float(quart['PriceWithTax']) * 100.0,2)
                if cnt < datalen-1:
                    nextprice = round(float(data[cnt+1]['PriceWithTax']) * 100.0,2)
                else:
                    nextprice = price

                if prevprice != 0:
                    if price == 0:
                        prevPriceRatio = 0.001 / prevprice
                    else:
                        prevPriceRatio = price /  prevprice

                if nextprice != 0:
                    if price == 0:
                        nextPriceRatio = 0.001 / nextprice
                    else:
                        nextPriceRatio = price / nextprice

                if prevprice + adder > price and nextprice + adder > price:  # this is a pit
                    if (prevPriceRatio > priceratio):
                        cheapQuarts.addRec(strTime(data[cnt-1]['DateTime']),prevprice,'beforebottom',ts-900)
                    cheapQuarts.addRec(strTime(quart['DateTime']),price,'bottom',ts)
                    if nextPriceRatio > priceratio and cnt+1 < datalen:
                        cheapQuarts.addRec(strTime(data[cnt+1]['DateTime']),nextprice,'afterbottom',ts+900)
                    cheapCnt += 1

                prevprice = price
            cnt += 1
        if cheapCnt < 24:
            print("cheapcount was only", cheapCnt, "breaking")
            break
        else:
            adder -= 0.1
            cheapQuarts.clear("cheaprank")



def removeDuplicates():
    if expensiveQuarts.count > cheapQuarts.count:
        for quart in cheapQuarts.times:
            expensiveQuarts.delRec(quart)

    if expensiveQuarts.count <= cheapQuarts.count:
        for quart in expensiveQuarts.times:
            cheapQuarts.delRec(quart)


def findDifferencies(data):
    stats = priceStats(data, 1, 96)

    print(datetime.utcnow(),"stats, min", stats.min, "max", stats.max, "avg", stats.avg)
    if stats.max - stats.min <= 2:
        return False

    return True


def queryCloud():

    try:
        data = requests.get(nordpool.BaseURL)

    except urllib.error.HTTPError  as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    except  urllib.error.URLError as e:
        ErrorInfo= e.read().decode()
        print(datetime.now(),'Error code: ', e.code, ErrorInfo)
        publishError(e.code, ErrorInfo)
        sys.exit()
    return data


if (len(sys.argv) < 2):
    print("Reading spot prices from internet")
else:
    filename = sys.argv[1]

pid = os.getpid()
client = mqtt.Client("nordpool reader" + str(pid)) #create new instance
client.on_connect = on_connect
client.on_message=on_message
client.on_publish=on_publish
client.on_disconnect = on_disconnect
client.connect(mqtt_broker.address,port = mqtt_broker.port, keepalive=60) 
print(datetime.utcnow(), "Start")
client.loop_start()
client.subscribe(mqtt_broker.topic_prefix + "/heating/setup")

# wait to get setup before query.
time.sleep(1)

cnt = 0
for i in range(3):
    if filename == 'cloud':
        x = queryCloud()
        data = x.json()
        if x.status_code != 200:
            publishError(x.status_code, x.reason)
            time.sleep(10)
            exit(0)
    else:
        try:
            file  = open(filename)
            data = json.loads(file.read())

        except FileNotFoundError:
            print(datetime.utcnow(),"file", filename,"not found.")
            exit(0)

    now = int(time.time())

    todayStats = dayStats(data, False)
    if todayStats.available:
        publisDayStats(todayStats.min, todayStats.max, todayStats.avg, todayStats.wday)
        print(todayStats.min, todayStats.max, todayStats.avg)

    tomorrowStats = dayStats(data, True)
    if tomorrowStats.available:
        publisDayStats(tomorrowStats.min, tomorrowStats.max, tomorrowStats.avg, tomorrowStats.wday)
        print(tomorrowStats.min, tomorrowStats.max, tomorrowStats.avg)

    if (findDifferencies(data)):
        findCheapQuartsByRank(data, 16)     # where rank is less than 16.
        findExpensiveQuartsByRank(data, 80) # where rank is over 80 ie 16 most expensives.
        findScatteredCheapQuarts(data)
        findScatteredExpensiveQuarts(data)
        removeDuplicates()

    for quart in data:
        ts = int(datetime.fromisoformat(quart['DateTime']).timestamp())
        if (ts > now):
            cnt = cnt +1
            if (cnt > 90):
                break

            cents = round(float(quart['PriceWithTax']) * 100,2)
            centsNoTax = round(float(quart['PriceNoTax']) * 100, 2)
            strquart=datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%H%M")
            topic = mqtt_broker.topic_prefix + "/elprice/" + strquart
            day = datetime.fromtimestamp(ts).astimezone(pytz.UTC).strftime("%Y%m%d%H%M")

            if cents == 0:
                pricestate = 'low'
            else:
                pricestate = 'normal'

                for cheaptime in cheapQuarts.times:
                    if cheaptime == day:
                        pricestate = 'low'
                        break

                for cheaptime in expensiveQuarts.times:
                    if cheaptime == day:
                        pricestate = 'high'
                        break

            send_msg = {
                    'id': 'elprice',
                    'quart': strquart,
                    'ts': ts,
                    'day': day,
                    'pricestate': pricestate,
                    'price': cents,
                    'notax': centsNoTax
            }

            msg = json.dumps(send_msg)
            if filename == 'cloud':
                client.publish(topic, msg, qos=0, retain=True)
            else:
                print(topic,msg)
    break

print(datetime.utcnow(),"done.")
